<!-- /chapters/ch04.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chapter 4 — Data Management & Storage Patterns</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Chapter 4 explores how to design storage for scalability, availability, and consistency. Topics: SQL vs NoSQL, indexing, replication, sharding, and specialized storage patterns.">
  <meta property="og:title" content="Chapter 4 — Data Management & Storage Patterns">
  <meta property="og:description" content="Design storage for scalability, availability, and consistency. Compare SQL vs. NoSQL, apply replication and sharding strategies, and learn specialized storage patterns.">
  <base href="../">
  <link rel="stylesheet" href="styles/theme.css">
  <script defer src="scripts/app.js"></script>
</head>
<body>
  <!-- ================= NAV (Canonical) ================= -->
  <nav class="app-nav">
    <div class="bar">
      <div class="brand"><a href="index.html">System Design</a></div>
      <button class="menu-btn" data-nav-toggle aria-expanded="false">Menu</button>
      <div class="spacer"></div>
      <div class="links">
        <a href="index.html">Home</a>
        <a href="chapters/ch01.html">Chapters</a>
        <a href="chapters/appendix.html">Appendix</a>
        <a href="chapters/glossary.html">Glossary</a>
      </div>
    </div>
  </nav>

  <!-- ================= HERO ================= -->
  <header class="page-hero container">
    <div class="badge">Chapter 4</div>
    <h1>Data Management &amp; Storage Patterns</h1>
    <p>
      Data is the beating heart of any system. Designing its storage requires balancing 
      <strong>scalability</strong>, <strong>availability</strong>, and <strong>consistency</strong>. 
      This chapter examines SQL vs. NoSQL trade-offs, indexing, replication, sharding, and 
      specialized stores for time-series, graphs, and search.
    </p>
  </header>

  <main class="container">
    <!-- PREREQS & OBJECTIVES -->
    <section class="section">
      <div class="grid two-col">
        <div class="card">
          <h2>Prerequisites</h2>
          <ul>
            <li>Comfort with CRUD operations and relational schemas.</li>
            <li>Basic familiarity with distributed systems and CAP theorem.</li>
            <li>Understanding of consistency vs. latency trade-offs.</li>
          </ul>
        </div>
        <div class="card">
          <h2>Learning Objectives</h2>
          <ul>
            <li>Compare relational and non-relational databases.</li>
            <li>Apply indexing, caching, and denormalization strategies.</li>
            <li>Design replication and sharding approaches for scale.</li>
            <li>Match specialized stores (time-series, graph, search) to workloads.</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- SECTION 1 -->
    <section class="section">
      <h2>1) Storage System Basics</h2>
      <h3>Relational vs. Non-relational</h3>
      <p>
        <strong>Relational databases</strong> (PostgreSQL, MySQL) enforce schemas, ACID guarantees, and strong consistency. 
        They excel when data integrity matters: banking, inventory, healthcare. 
        <strong>NoSQL databases</strong> (MongoDB, Cassandra, DynamoDB) sacrifice strict schema or consistency for 
        horizontal scalability, flexible structures, or high availability.
      </p>
      <div class="callout info">
        <strong>CAP Theorem Recap:</strong> In a network partition, you must choose 
        between <abbr title="Every request gets the most recent data or error">consistency</abbr> 
        and <abbr title="Every request receives a response, even if stale">availability</abbr>. 
        Systems pick trade-offs along this triangle.
      </div>
    </section>

    <!-- SECTION 2 -->
    <section class="section">
      <h2>2) Indexing &amp; Query Optimization</h2>
      <p>
        Indexes speed queries but add write overhead. A <strong>B-tree index</strong> supports range queries, 
        while a <strong>hash index</strong> optimizes equality lookups. 
        <strong>Denormalization</strong>—duplicating data for read speed—is common in large-scale systems. 
        Combine with <strong>caching layers</strong> (Redis, Memcached) to reduce DB load.
      </p>
      <h3>Example: Dashboard</h3>
      <p>
        A metrics dashboard reading millions of rows per minute uses a denormalized table 
        of pre-aggregated counts, backed by a cache. Trade-off: more complex writes, 
        simpler reads.
      </p>
    </section>

    <!-- SECTION 3 -->
    <section class="section">
      <h2>3) Replication &amp; Sharding Strategies</h2>
      <h3>Replication</h3>
      <p>
        <strong>Leader–follower</strong> setups provide durability and scale reads. 
        <strong>Multi-leader</strong> improves availability but risks conflicts. 
        <strong>Quorum-based</strong> systems (Cassandra, Dynamo) balance consistency and availability dynamically.
      </p>
      <h3>Sharding</h3>
      <p>
        Split data across nodes by key (<strong>hash-based</strong>) or by range (<strong>range-based</strong>). 
        Sharding reduces load but adds complexity in rebalancing, cross-shard queries, and transaction guarantees.
      </p>
      <figure>
        <img src="../assets/ch04-sharding-diagram.svg" alt="Diagram of hash vs range sharding across nodes">
        <figcaption>Hash sharding spreads evenly, range sharding supports range queries but risks hotspots.</figcaption>
      </figure>
    </section>

    <!-- SECTION 4 -->
    <section class="section">
      <h2>4) Specialized Storage Patterns</h2>
      <ul>
        <li><strong>Time-series databases</strong> (InfluxDB, Timescale): optimized for writes and queries on timestamps.</li>
        <li><strong>Graph databases</strong> (Neo4j): efficient for traversals like “friends of friends.”</li>
        <li><strong>Search engines</strong> (Elasticsearch): inverted indexes, optimized for text search.</li>
      </ul>
      <div class="callout warn">
        <strong>Trade-off:</strong> Specialized stores add power but increase operational burden. 
        Evaluate whether a general-purpose DB with proper indexes suffices before adding another technology.
      </div>
    </section>

    <!-- ANALOGY -->
    <section class="section">
      <h2>Analogy: Libraries &amp; Storage</h2>
      <p>
        A <strong>relational DB</strong> is like a meticulously cataloged library: 
        every book has a fixed place (schema). A <strong>NoSQL store</strong> is like a flexible 
        reading room: books may be scattered but quick to grab. A <strong>graph DB</strong> is 
        more like a web of references, akin to a researcher’s citation network. 
        Each structure serves different goals.
      </p>
    </section>

    <!-- COMPARE & CONTRAST -->
    <section class="section">
      <h2>Compare &amp; Contrast: SQL vs. NoSQL</h2>
      <table>
        <thead>
          <tr><th>Aspect</th><th>SQL</th><th>NoSQL</th></tr>
        </thead>
        <tbody>
          <tr><td>Schema</td><td>Rigid, normalized</td><td>Flexible, dynamic</td></tr>
          <tr><td>Transactions</td><td>ACID, strong consistency</td><td>Often BASE, eventual consistency</td></tr>
          <tr><td>Scalability</td><td>Vertical (scale-up) + read replicas</td><td>Horizontal sharding built-in</td></tr>
          <tr><td>Best For</td><td>Banking, inventory, critical data integrity</td><td>High-throughput, flexible workloads</td></tr>
        </tbody>
      </table>
    </section>

    <!-- CASE STUDY -->
    <section class="section">
      <h2>Case Study: Sharding a Messaging App (≈200 words)</h2>
      <p>
        A messaging app initially stored all user messages in a single relational database. 
        As users grew to millions, queries slowed, backups became unwieldy, and single-node 
        failure was catastrophic. The team adopted <strong>hash-based sharding</strong> by user ID, 
        distributing data across ten database nodes. Each shard handled a subset of users, 
        improving performance. For group chats crossing shards, they added a service layer to 
        aggregate messages. Replication was added within each shard for durability, with one 
        leader and two followers. The result: horizontal scale-out and reduced single points 
        of failure. Trade-off: cross-shard operations became complex, requiring changes in 
        application logic and monitoring. Eventually, they introduced a <strong>search index</strong> 
        (Elasticsearch) for message lookup, since cross-shard LIKE queries were inefficient. 
        The lesson: sharding improves scalability but pushes complexity upward into the application 
        and supporting infrastructure.
      </p>
    </section>

    <!-- RESOURCES -->
    <section class="section">
      <h2>Recommended Resources</h2>
      <div class="resource-list">
        <div class="item"><strong>Designing Data-Intensive Applications (Ch.3–6)</strong><div class="meta">Deep dive into storage trade-offs.</div></div>
        <div class="item"><strong>MongoDB &amp; PostgreSQL Docs</strong><div class="meta">Practical guides to schema, indexing, and replication.</div></div>
        <div class="item"><strong>Elasticsearch Guide</strong><div class="meta">How inverted indexes power fast search.</div></div>
      </div>
    </section>

    <!-- PRACTICE -->
    <section class="section practice">
      <h2>Practice</h2>
      <div class="task">
        <h3>Design a Schema for a Messaging App</h3>
        <p class="meta">⏱️ 45–60 min · Success: schema supports users, messages, and threads efficiently</p>
      </div>
      <div class="task">
        <h3>Propose a Sharding Strategy</h3>
        <p class="meta">⏱️ 40–50 min · Success: clear partitioning key, handling of cross-shard queries</p>
      </div>
      <div class="task">
        <h3>Indexing Exercise</h3>
        <p class="meta">⏱️ 20–30 min · Success: index selection justified by workload patterns</p>
      </div>
    </section>

    <!-- MASTERY -->
    <section class="section mastery">
      <h2>Mastery Check</h2>
      <div class="quiz-controls">
        <button class="btn" data-quiz-toggle="open">Open all answers</button>
        <button class="btn" data-quiz-toggle="close">Close all</button>
      </div>
      <details>
        <summary>1) When do you prefer SQL over NoSQL?</summary>
        <div><p>When data integrity and ACID transactions are critical—banking, healthcare, inventory systems.</p></div>
      </details>
      <details>
        <summary>2) What problem does sharding solve?</summary>
        <div><p>Removes bottlenecks by spreading data across nodes, enabling horizontal scalability and reducing single-node load.</p></div>
      </details>
      <details>
        <summary>3) Risk of multi-leader replication?</summary>
        <div><p>Write conflicts; requires conflict resolution strategies like last-write-wins or CRDTs.</p></div>
      </details>
      <details>
        <summary>4) Example of time-series DB use case?</summary>
        <div><p>IoT sensor readings, server monitoring metrics, stock price data with timestamped writes.</p></div>
      </details>
      <details>
        <summary>5) Why denormalize?</summary>
        <div><p>To optimize read-heavy workloads by reducing joins at the expense of more complex writes.</p></div>
      </details>
      <details>
        <summary>6) How does quorum-based consistency work?</summary>
        <div><p>A read/write is acknowledged once it reaches a majority of replicas; balances consistency and availability per operation.</p></div>
      </details>
    </section>

    <!-- RECAP -->
    <section class="section">
      <h2>Recap &amp; Next Steps</h2>
      <p>
        You explored SQL vs. NoSQL, indexing, replication, and sharding, with case studies 
        and trade-offs. Specialized stores can unlock performance for narrow workloads, 
        but add operational cost. Next, Chapter 5 tackles <strong>scaling &amp; reliability strategies</strong>.
      </p>
    </section>

    <!-- NEXT/PREV -->
    <nav class="next-prev" aria-label="Chapter navigation">
      <a href="chapters/ch03.html" rel="prev">Previous: Communication &amp; Networking</a>
      <a href="chapters/ch05.html" rel="next">Next: Scaling &amp; Reliability Strategies</a>
    </nav>

    <!-- HIDDEN CHECKLIST -->
    <!--
    - [x] theme.css+app.js loaded
    - [x] <base> present & correct
    - [x] Canonical nav verbatim
    - [x] Pager prev/next valid
    - [x] ≥1,200 words
    - [x] ≥2 examples, 1 case study, 1 compare/contrast, 1 analogy
    - [x] Practice 3–5
    - [x] Mastery 5–7
    - [x] ≥8 glossarized terms
    - [x] ≥1 figure
    -->
  </main>
</body>
</html>
