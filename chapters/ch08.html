<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <base href="../">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Chapter 08 — Designing for Evolution and Extensibility</title>
  <meta name="description" content="Strategies to evolve systems safely: feature flags and rollouts, backward compatibility and schema evolution, refactoring at scale with the Strangler pattern, and pragmatic tech-debt management.">
  <meta property="og:title" content="Chapter 08 — Designing for Evolution and Extensibility">
  <meta property="og:description" content="Plan and execute change without breaking users: toggles, migrations, API and schema versioning, domain boundaries, and debt metrics with a monolith→microservices checkpoint.">
  <meta property="og:type" content="article">
  <meta name="theme-color" content="#0b0f14">
  <link rel="stylesheet" href="styles/theme.css">
  <script src="scripts/app.js" defer></script>
</head>
<body>
  <a class="skip-link" href="#main">Skip to main content</a>

  <!-- Canonical Top Navigation (copy verbatim to all pages) -->
  <nav class="app-nav">
    <div class="container inner">
      <div class="brand">System Design — Intermediate</div>
      <button class="toggle js-nav-toggle" aria-expanded="false" aria-controls="primary-menu">Menu</button>
      <div id="primary-menu" class="menu" role="navigation" aria-label="Primary">
        <a href="index.html">Home</a>
        <a href="chapters/appendix.html">Appendix</a>
        <a href="chapters/glossary.html">Glossary</a>
      </div>
    </div>
  </nav>

  <header class="page-hero" id="ch08-hero">
    <div class="container">
      <div class="meta">
        <span class="badge badge-primary">Chapter 08</span>
        <span class="badge">Evolution &amp; Extensibility</span>
      </div>
      <h1>Designing for Evolution and Extensibility</h1>
      <p class="abstract">Change is the only constant. Systems that thrive over years are built to evolve safely: they hide new code behind flags, preserve backward compatibility through deliberate contracts, migrate data and APIs without surprises, and carve clear domain boundaries so refactors don’t ripple everywhere. In this chapter you will plan safe rollouts, version APIs and schemas, apply the Strangler pattern to decompose a monolith, and measure technical debt so it doesn’t quietly eat your roadmap.</p>
    </div>
  </header>

  <main id="main" class="container">
    <!-- 08.1 -->
    <section class="section" id="ch08-1">
      <h2>08.1 System Evolution</h2>
      <p id="ch08-1-why">Why it matters: Every feature and fix introduces risk. Evolution techniques let you change behavior in production while limiting blast radius and collecting evidence that you are safe to proceed.</p>

      <h3 id="ch08-1-1">08.1.1 Feature Toggles and Progressive Delivery</h3>
      <p><strong>Plain:</strong> A feature toggle (flag) is a conditional that allows you to turn a behavior on or off at runtime without redeploying. Progressive delivery gradually increases exposure: from internal users, to 1% of customers, to everyone.</p>
      <p><strong>Formal:</strong> A <em>flag</em> evaluates a targeting rule (by user, tenant, region, device) to produce a treatment (<code>on</code>/<code>off</code>/<code>variant</code>). Progressive rollout uses staged policies: <em>beta</em> (employees), <em>canary</em> (1–5%), <em>ramp</em> (10→25→50→100%), with automatic rollback based on SLIs (error rate, latency, conversion). Flags must be <em>server-evaluated</em> for sensitive logic and cached locally with a <em>TTL</em> to reduce request-time overhead. Always attach <em>kill switches</em> for quick disable.</p>
      <p><strong>Pitfall:</strong> “Flag forever.” Long-lived toggles become hidden complexity and divergent code paths. Set an <em>expiry date</em> for each flag and track owners; delete toggles once a feature is fully rolled out.</p>

      <figure>
        <img src="https://docs.aws.amazon.com/images/codedeploy/latest/userguide/images/deployment-architecture-blue-green.png" alt="Blue/green deployment architecture with two parallel environments and traffic switching" loading="lazy" decoding="async" width="864" height="480" referrerpolicy="no-referrer">
        <figcaption>Blue/green keeps old and new code in parallel so traffic can be shifted safely (AWS CodeDeploy Docs, 2024–2025).</figcaption>
      </figure>

      <h3 id="ch08-1-2">08.1.2 Rollout Strategies</h3>
      <p><strong>Plain:</strong> Don’t flip a giant switch. Choose a rollout that matches risk.</p>
      <ul>
        <li><strong>Blue/Green:</strong> Run two identical environments; shift traffic from blue (old) to green (new). Fast rollback by switching back.</li>
        <li><strong>Canary:</strong> Send a small percentage to the new version first; watch SLIs and expand if healthy.</li>
        <li><strong>Rolling:</strong> Incrementally replace instances; good default when risk is moderate and per-instance state is low.</li>
      </ul>

      <figure>
        <img src="https://docs.aws.amazon.com/images/codedeploy/latest/userguide/images/deployment-architecture-rolling.png" alt="Rolling deployment replacing instances in batches with health checks" loading="lazy" decoding="async" width="864" height="480" referrerpolicy="no-referrer">
        <figcaption>Rolling deployment replaces instances in batches with health checks to limit blast radius (AWS CodeDeploy Docs, 2024–2025).</figcaption>
      </figure>

      <p><em>Compare: Rollout Methods</em></p>
      <table>
        <thead>
          <tr><th>Method</th><th>Risk</th><th>Rollback speed</th><th>Cost</th><th>Best for</th></tr>
        </thead>
        <tbody>
          <tr><td>Blue/Green</td><td>Low</td><td>Instant switch</td><td>Higher (double capacity)</td><td>High-risk releases, schema changes</td></tr>
          <tr><td>Canary</td><td>Low–Medium</td><td>Fast (reduce %)</td><td>Low–Medium</td><td>Most feature releases</td></tr>
          <tr><td>Rolling</td><td>Medium</td><td>Medium</td><td>Low</td><td>Routine deploys</td></tr>
        </tbody>
      </table>

      <h3 id="ch08-1-3">08.1.3 Observability for Evolution</h3>
      <p><strong>Plain:</strong> You can’t safely expand a rollout if you can’t see its impact.</p>
      <p><strong>Formal:</strong> Attach <em>experiment keys</em> (flag name, variant) and <em>build metadata</em> (commit, version) to logs and traces. Segment your SLIs by variant and tenant. Use burn-rate alerts keyed to the canary slice so a small failure pages quickly without hiding in the global average.</p>

      <p class="summary">Takeaway: Treat every change as an experiment. Use flags and staged rollouts, watch user-facing SLIs, and make rollback a button, not a project.</p>
    </section>

    <!-- 08.2 -->
    <section class="section" id="ch08-2">
      <h2>08.2 Backward Compatibility</h2>
      <p id="ch08-2-why">Why it matters: Users and services depend on you. Breaking changes cascade through teams and customers. Backward compatibility lets you deploy independently and evolve quickly without forcing lockstep upgrades.</p>

      <h3 id="ch08-2-1">08.2.1 API Versioning &amp; Compatibility Contracts</h3>
      <p><strong>Plain:</strong> When you change an API, you either keep old clients working or you give them a predictable way to move.</p>
      <p><strong>Formal:</strong> Compatibility hinges on a clear contract. Common patterns:</p>
      <ul>
        <li><strong>Semantic Versioning (SemVer):</strong> <code>MAJOR.MINOR.PATCH</code>. Backward-compatible additions bump <em>MINOR</em>; breaking changes bump <em>MAJOR</em>. Libraries and SDKs often use this.</li>
        <li><strong>Resource Versioning:</strong> Version field or media type: <code>Accept: application/vnd.api+json;version=2</code>, or path-based <code>/v2/</code>. Keep <em>two adjacent versions</em> live during migration, deprecate with dates.</li>
        <li><strong>Schema Evolution (Protobuf/Avro):</strong> Additive changes (new optional fields) are backward compatible; never reuse or repurpose field numbers; reserve removed fields.</li>
      </ul>
      <p><strong>Pitfall:</strong> “Silent” breaking changes—renaming fields, changing types, or tightening validation without bumping a version. Bake compatibility checks into CI with contract tests and schema diffs.</p>

      <h3 id="ch08-2-2">08.2.2 Database Schema Evolution</h3>
      <p><strong>Plain:</strong> Most outages during change involve the database. Evolve schemas with <em>expand/contract</em> patterns so app and DB changes can ship independently.</p>
      <p><strong>Formal:</strong> Use a two-phase dance:</p>
      <ol>
        <li><strong>Expand:</strong> Add new columns/tables that the new code needs. Make them nullable or defaulted. Double-write if necessary (old &amp; new).</li>
        <li><strong>Migrate:</strong> Backfill data in small batches with throttling; verify parity via checksums or sample queries.</li>
        <li><strong>Cutover:</strong> Flip reads to the new schema/column (behind a flag), monitor, then stop writing old paths.</li>
        <li><strong>Contract:</strong> Remove old columns/indexes in a separate deploy after a cooldown window.</li>
      </ol>
      <p><strong>Pitfall:</strong> Locking and long-running migrations. For large tables, prefer <em>online schema change</em> tools (e.g., shadow copy + triggers) and partitioned backfills instead of <code>ALTER TABLE</code> that blocks writes.</p>

      <h3 id="ch08-2-3">08.2.3 Idempotency and Tolerant Readers</h3>
      <p><strong>Plain:</strong> New producers and old consumers will coexist. <em>Tolerant readers</em> ignore unknown fields; <em>idempotent writers</em> allow safe retries during cutovers.</p>
      <p><strong>Formal:</strong> For JSON, require consumers to ignore extra properties and default missing ones. For Protobuf/Avro, unknown fields are already ignored if you don’t reuse tags. For side-effecting operations during migration, require idempotency keys or natural idempotence (upserts with unique constraints).</p>

      <p class="summary">Takeaway: Make compatibility a product feature. Use explicit versioning, schema-safe evolutions, tolerant readers, and idempotent writes so you can ship changes continuously.</p>
    </section>

    <!-- 08.3 -->
    <section class="section" id="ch08-3">
      <h2>08.3 Refactoring at Scale</h2>
      <p id="ch08-3-why">Why it matters: Systems accrete complexity. Refactoring reduces accidental complexity <em>without</em> changing behavior so you can move faster on purpose. At scale, refactors must be safe, staged, and reversible.</p>

      <h3 id="ch08-3-1">08.3.1 Domain Boundaries and Contracts</h3>
      <p><strong>Plain:</strong> If your system has fuzzy boundaries, every change is risky. Clear domains reduce coupling and make refactors local.</p>
      <p><strong>Formal:</strong> Use <em>bounded contexts</em> (Domain-Driven Design) to define responsibility and language for each domain (e.g., <em>Identity</em>, <em>Catalog</em>, <em>Orders</em>). Contracts between contexts are thin and explicit: an API, an event schema, or a replicated read model. Avoid sharing database tables across contexts.</p>
      <p><strong>Pitfall:</strong> “Microservices” that are just a distributed monolith—many services still sharing a database and deployment timeline.</p>

      <h3 id="ch08-3-2">08.3.2 The Strangler Pattern</h3>
      <p><strong>Plain:</strong> Replace a monolith piece by piece. Route a small subset of flows to a new service, then grow it until the old piece dies—like a strangler fig around a tree (hence the name).</p>
      <p><strong>Formal:</strong> Put a <em>routing seam</em> in front of the monolith (proxy/gateway). For the first capability you carve out, duplicate data flows: the new service handles reads/writes for just that capability; an <em>anti-corruption layer</em> translates between old and new models. When the new service is stable and the old code is unused, you delete the old code path and repeat.</p>

      <figure>
        <img src="https://martinfowler.com/bliki/images/strangler/stranglerFig.png" alt="Strangler Fig pattern metaphor: a new system grows around the legacy and gradually replaces it" loading="lazy" decoding="async" width="352" height="542" referrerpolicy="no-referrer">
        <figcaption>The Strangler pattern replaces legacy functionality incrementally (Martin Fowler, 2004–2020).</figcaption>
      </figure>

      <h3 id="ch08-3-3">08.3.3 Safety Nets: Tests, Shadow Traffic, and Replay</h3>
      <p><strong>Plain:</strong> Big refactors fail when they rely on heroics. Use automated checks and production signals.</p>
      <ul>
        <li><strong>Contract tests:</strong> Validate that your service honors API/event contracts from both sides (provider &amp; consumer).</li>
        <li><strong>Shadow traffic:</strong> Mirror a slice of production requests to the new service (responses discarded) to measure correctness and performance before switching.</li>
        <li><strong>Replay harness:</strong> Reproduce recent traffic from logs/queues against the new service with idempotency to verify results quickly.</li>
      </ul>
      <p><strong>Pitfall:</strong> “Big bang” rewrites that never ship. Prefer vertical slices you can route within weeks.</p>

      <h3 id="ch08-3-4">08.3.4 When Not to Split</h3>
      <p><strong>Plain:</strong> Splitting a service adds costs: latency between services, more deployments, more monitoring. If you don’t gain independent scaling or ownership, don’t split.</p>
      <p><strong>Formal:</strong> Evaluate against three axes: <em>independence</em> (can a team own and ship it alone?), <em>scalability</em> (does it have distinct load patterns?), and <em>risk isolation</em> (does it reduce blast radius?). If “no” on all three, refactor <em>inside</em> the service instead (modules, packages, clear interfaces).</p>

      <p class="summary">Takeaway: Carve along domain seams, route gradually with a proxy, and use shadowing/replay to de-risk. Split services only when benefits beat the permanent costs.</p>
    </section>

    <!-- 08.4 -->
    <section class="section" id="ch08-4">
      <h2>08.4 Tech Debt Management</h2>
      <p id="ch08-4-why">Why it matters: Debt trades speed now for cost later. Without measurement and disciplined paydown, the interest crowds out new features and reliability.</p>

      <h3 id="ch08-4-1">08.4.1 Defining and Sizing Debt</h3>
      <p><strong>Plain:</strong> Tech debt is code, design, or operational shortcuts you keep paying for. Not all debt is bad; some is a smart bet if you repay it.</p>
      <p><strong>Formal:</strong> Use a simple <em>principal × interest</em> model. <em>Principal</em> is the one-time cost to fix (e.g., 5 engineer-days). <em>Interest</em> is the recurring cost (e.g., 2 hours/week in incidents or workarounds). Prioritize items with high interest, especially those that hit SLIs or delivery velocity. Add <em>risk</em> as a multiplier when a debt can cause severe outages (e.g., a single-tenant hotspot).</p>

      <h3 id="ch08-4-2">08.4.2 Metrics That Matter</h3>
      <ul>
        <li><strong>Change failure rate:</strong> % of deploys causing incidents or rollbacks.</li>
        <li><strong>Lead time for changes:</strong> Idea → production. Rising times indicate friction.</li>
        <li><strong>MTTR:</strong> Mean time to recover; a proxy for how understandable and operable the system is.</li>
        <li><strong>Cycle time by domain:</strong> If one domain’s changes consistently lag, the architecture may be fighting you.</li>
      </ul>
      <p><strong>Pitfall:</strong> Counting only code smells. Architectural and data debts (shared databases, “god” tables, missing indexes) usually dominate impact.</p>

      <h3 id="ch08-4-3">08.4.3 Governance &amp; Paydown Cadence</h3>
      <p><strong>Plain:</strong> If paying debt is “extra,” it never happens. Bake it into planning.</p>
      <p><strong>Formal:</strong> Set a policy like “allocate 15–20% of capacity to reliability and debt every sprint.” Maintain a <em>debt register</em> with owner, principal, interest, and risk. Tie items to measurable outcomes (e.g., reduce MTTR by 20%). Make debt reduction a first-class goal in quarterly plans, not ad-hoc favors.</p>

      <h3 id="ch08-4-4">08.4.4 Communication: Debt as Strategy</h3>
      <p><strong>Plain:</strong> Non-technical stakeholders fund what they understand. Tell the story in outcomes.</p>
      <p><strong>Formal:</strong> Express debt in unit economics: “This refactor reduces checkout latency P95 by 80 ms, worth +₹X/month revenue, and halves incident minutes.” Use dashboards to show trend lines before/after.</p>

      <p class="summary">Takeaway: Measure principal and interest, prioritize by impact on reliability and speed, and schedule paydown as a habit. Communicate outcomes, not just refactor plans.</p>
    </section>

    <!-- 08.5 -->
    <section class="section" id="ch08-5">
      <h2>08.5 Checkpoints — Monolith → Microservices Migration</h2>
      <p id="ch08-5-why">Why it matters: Many teams start with a monolith for good reasons. When growth forces change, a disciplined migration avoids the “distributed big ball of mud.”</p>

      <h3 id="ch08-5-1">08.5.1 Scenario &amp; Constraints</h3>
      <ul>
        <li>Monolith handles <em>Catalog</em>, <em>Orders</em>, <em>Billing</em>, <em>Identity</em>. Peak: 3k RPS API; background jobs for emails and exports.</li>
        <li>Pain points: slow deploys (45 minutes), shared database schema, incidents bleed across features, P95 checkout latency 600&nbsp;ms.</li>
        <li>Constraints: one quarter, two squads, budget-conscious. SLOs must not worsen during migration.</li>
      </ul>

      <h3 id="ch08-5-2">08.5.2 8-Step Migration Plan</h3>
      <ol>
        <li><strong>Draw boundaries:</strong> Choose first domain with strong ROI and clear seams—<em>Identity</em> or <em>Catalog</em> are common. Write domain docs and API/event contracts.</li>
        <li><strong>Put a routing seam:</strong> Deploy an API gateway in front. All traffic goes through it so you can route per-endpoint to monolith or new services.</li>
        <li><strong>Clone data paths:</strong> Introduce an event log or CDC to publish changes out of the monolith database (e.g., <code>UserCreated</code>, <code>ProductUpdated</code>). New services subscribe to build their own stores.</li>
        <li><strong>Build the first service:</strong> Implement <em>Catalog</em> as a separate service with its own DB. Provide read models for the monolith temporarily so UI/API don’t change yet.</li>
        <li><strong>Shadow &amp; replay:</strong> Mirror 5–10% of production requests to the new service. Fix gaps discovered under real traffic.</li>
        <li><strong>Route progressively:</strong> Canary actual traffic (1%→10%→50%→100%) behind a feature flag. Keep rollback switch ready.</li>
        <li><strong>Cut old code:</strong> Remove monolith catalog code once the new path is stable; delete shared tables; enforce boundaries.</li>
        <li><strong>Repeat:</strong> Move to the next domain (<em>Orders</em>). Reuse the playbook, refine with lessons learned.</li>
      </ol>

      <h3 id="ch08-5-3">08.5.3 Risks &amp; Mitigations</h3>
      <ul>
        <li><strong>Dual writes inconsistency:</strong> Use outbox pattern to atomically publish events with writes; reconcile via periodic checks.</li>
        <li><strong>Latency regressions:</strong> Co-locate services and databases; use bulk endpoints and caching; measure P95/P99 per route during rollout.</li>
        <li><strong>Ownership confusion:</strong> Each new service must have a clear team owner, on-call, and roadmap; avoid “orphan” services.</li>
        <li><strong>Schema drift:</strong> Freeze shared DB writes early; derive read models instead of sharing tables.</li>
      </ul>

      <h3 id="ch08-5-4">08.5.4 Success Criteria</h3>
      <ul>
        <li>Checkout P95 ≤ 300&nbsp;ms; change failure rate ≤ 10%; MTTR ≤ 30 minutes.</li>
        <li>Independent deploys for two domains with &lt; 10 minutes pipeline time.</li>
        <li>Zero user-visible downtime during cutovers; <em>replay</em> &amp; <em>shadow</em> coverage ≥ 80% of hot endpoints.</li>
      </ul>

      <p class="summary">Deliverables: a migration diagram (gateway seam, topics, new service DBs), a rollout runbook with flags and canaries, a compatibility matrix (old vs new contracts), and an SLO dashboard segmented by route.</p>
    </section>

    <!-- Resources -->
    <section class="section" id="ch08-resources">
      <h2>Resources</h2>
      <ul class="resource-list">
        <li><strong>Martin Fowler — Strangler Fig &amp; Evolutionary Architecture</strong> — Canonical guidance on incremental replacement and fitness functions (Fowler, 2004–2020). <span class="badge">Free</span></li>
        <li><strong>ThoughtWorks Technology Radar</strong> — Pragmatic positions on flags, progressive delivery, and architectural practices (ThoughtWorks, 2024–2025). <span class="badge">Free</span></li>
        <li><strong>Protobuf/Avro Schema Evolution</strong> — Official docs on compatible changes and field numbering (Google/Apache, ongoing). <span class="badge">Free</span></li>
        <li><strong>AWS CodeDeploy Docs</strong> — Blue/green, canary, and rolling strategies with concrete runbooks (AWS, 2024–2025). <span class="badge">Free</span></li>
        <li><strong>Domain-Driven Design References</strong> — Bounded contexts and anti-corruption layers to carve seams (Evans/Community). <span class="badge">Paid/Free</span></li>
      </ul>
      <p class="muted">Rationales: These sources remain current for rollout mechanics, schema compatibility rules, and incremental migration patterns that align with this chapter’s techniques.</p>
    </section>

    <!-- Recap -->
    <section class="section" id="ch08-recap">
      <h2>Recap &amp; Next Steps</h2>
      <ul>
        <li>Use <em>flags</em> and <em>progressive delivery</em> to de-risk change and make rollback instant.</li>
        <li>Preserve <em>backward compatibility</em> with explicit versioning, tolerant readers, and expand/contract schema changes.</li>
        <li>Refactor along <em>domain boundaries</em>; apply the <em>Strangler</em> pattern with shadow traffic and replay harnesses.</li>
        <li>Manage <em>tech debt</em> with principal/interest/risk; reserve capacity every sprint to keep velocity and reliability healthy.</li>
      </ul>
      <p><strong>Next Steps:</strong></p>
      <ol>
        <li>Pick one domain in your capstone and sketch a strangler plan: gateway rules, events to publish, read models to build, and the first cutover milestone.</li>
        <li>Write an API compatibility policy (versioning, deprecation windows, supported ranges) and add contract tests to CI.</li>
        <li>Start a debt register with top 10 items, estimating principal and interest; allocate 15–20% team capacity for paydown next sprint.</li>
      </ol>
    </section>

    <!-- Pager -->
    <nav class="next-prev">
      <a class="prev" rel="prev" href="chapters/ch07.html"><span class="muted">Prev</span><span>← Chapter 07 — Security and Compliance in Distributed Systems</span></a>
      <a class="next" rel="next" href="chapters/ch09.html"><span class="muted">Next</span><span>Chapter 09 — Capstone Project: Architecting a Scalable System →</span></a>
    </nav>

    <!-- Image Link Audit -->
    <section class="section" id="ch08-image-audit">
      <h2>Image Link Audit</h2>
      <ul class="resource-list">
        <li>https://docs.aws.amazon.com/images/codedeploy/latest/userguide/images/deployment-architecture-blue-green.png — <strong>200 OK</strong>, content-type <strong>image/png</strong> — <span class="badge badge-success">pass</span></li>
        <li>https://docs.aws.amazon.com/images/codedeploy/latest/userguide/images/deployment-architecture-rolling.png — <strong>200 OK</strong>, content-type <strong>image/png</strong> — <span class="badge badge-success">pass</span></li>
        <li>https://martinfowler.com/bliki/images/strangler/stranglerFig.png — <strong>200 OK</strong>, content-type <strong>image/png</strong> — <span class="badge badge-success">pass</span></li>
      </ul>
      <p class="muted">Only HTTPS, non-SVG images with 200 OK and image/* MIME types are included.</p>
    </section>

    <!--
    CHECKLIST
    - [x] /styles/theme.css + /scripts/app.js linked; <base> correct; no inline nav JS
    - [x] Canonical nav (Home / Appendix / Glossary only)
    - [x] Pager prev/next valid; ToC numbering matches
    - [x] Order: Hero → Numbered Sections → Resources → Recap
    - [x] ≥1,800 words of prose (headings, paragraphs, lists, tables; code blocks excluded)
    - [x] Images: HTTPS, non-SVG, validated 200 OK image/*; captions + attribution included
    - [x] Head/meta complete; no TODOs
    -->
  </main>
</body>
</html>

